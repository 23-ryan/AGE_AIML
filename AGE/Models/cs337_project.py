# -*- coding: utf-8 -*-
"""cs337-project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wf1q4WTSz1kLJBIY4NVbJnp-TfOYNxYN
"""

import os
import cv2
import numpy as np
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras import Input
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, BatchNormalization, Concatenate
from tensorflow.keras.optimizers import Adam
from tqdm import tqdm
from scipy.stats import mode



# os.chdir('/IMG')
os.environ["CUDA_VISIBLE_DEVICES"]="4"

all_x = []
all_age = []
all_gender = []
all_eth = []

images = os.listdir('Image2/')
for path in tqdm(images):
    if path.split('_')[0].isdigit() and path.split('_')[1].isdigit() and path.split('_')[2].isdigit():
        img = cv2.imread(f"Image2/{path}")
        # if img == None:
        #     print(path)
        all_x.append(list(img))
        all_age.append(int(path.split('_')[0]))
        all_gender.append(int(path.split('_')[1]))
        all_eth.append(int(path.split('_')[2]))

all_x = np.array(all_x)
all_age = np.array(all_age)
all_gender = np.array(all_gender)
all_eth = np.array(all_eth)
print(all_x.shape)
train_images, test_images, train_age, test_age, train_gender, test_gender, train_eth, test_eth = train_test_split(
    all_x, all_age, all_gender, all_eth, test_size=0.2, random_state=42
)

train_images.shape, test_images.shape

train_age.shape, test_age.shape

def create_model(type):
    if type==0:
        gender_model = Sequential()
        gender_model.add(Conv2D(32, (7, 7), activation='relu', input_shape=(128, 128, 3)))
        gender_model.add(BatchNormalization())
        gender_model.add(MaxPooling2D((2, 2)))
        gender_model.add(Conv2D(64, (5, 5), activation='relu'))
        gender_model.add(BatchNormalization())
        gender_model.add(MaxPooling2D((2, 2)))
        gender_model.add(Conv2D(128, (5, 5), activation='relu'))
        gender_model.add(Conv2D(128, (3, 3), activation='relu'))
        gender_model.add(Conv2D(128, (3, 3), activation='relu'))
        gender_model.add(MaxPooling2D((2, 2)))
        gender_model.add(Flatten())
        gender_model.add(Dense(128, activation='relu'))
        gender_model.add(Dropout(0.5))
        gender_model.add(Dense(1, activation='sigmoid'))
        gender_model.compile(optimizer=Adam(learning_rate=.0001), loss='binary_crossentropy', metrics=['accuracy'])
        return gender_model


    elif type==1:
        age_model = Sequential()
        age_model.add(Conv2D(32, (7, 7), activation='relu', input_shape=(128, 128, 3)))
        age_model.add(BatchNormalization())
        age_model.add(MaxPooling2D((2, 2)))
        age_model.add(Conv2D(64, (5, 5), activation='relu'))
        age_model.add(BatchNormalization())
        age_model.add(MaxPooling2D((2, 2)))
        age_model.add(Conv2D(128, (5, 5), activation='relu'))
        # age_model.add(Conv2D(128, (3, 3), activation='relu'))
        # age_model.add(Conv2D(128, (3, 3), activation='relu'))
        age_model.add(BatchNormalization())
        age_model.add(MaxPooling2D((2, 2)))
        age_model.add(Flatten())
        # age_model.add(Dense(128, activation='relu'))
        # age_model.add(Dropout(0.5))
        # age_model.add(Dense(100, activation='sigmoid'))
        age_model.add(Dense(128, activation='relu'))
        age_model.add(Dropout(0.5))
        age_model.add(Dense(1, activation='linear'))

        # Compile the model
        age_model.compile(optimizer=Adam(), loss='mae')
        # age_model.compile(optimizer=Adam(learning_rate=0.001), loss='mae')

        return age_model

    else:
        eth_model = Sequential()
        eth_model.add(Conv2D(32, (7, 7), activation='relu', input_shape=(128, 128, 3)))
        eth_model.add(BatchNormalization())
        eth_model.add(MaxPooling2D((2, 2)))
        eth_model.add(Conv2D(64, (5, 5), activation='relu'))
        eth_model.add(BatchNormalization())
        eth_model.add(MaxPooling2D((2, 2)))
        eth_model.add(Conv2D(128, (5, 5), activation='relu'))
        eth_model.add(Conv2D(128, (3, 3), activation='relu'))
        eth_model.add(BatchNormalization())
        eth_model.add(MaxPooling2D((2, 2)))
        eth_model.add(Flatten())
        eth_model.add(Dense(128, activation='relu'))
        eth_model.add(Dropout(0.5))

        eth_model.add(Dense(5, activation='softmax'))

        # Compile the model
        eth_model.compile(optimizer=Adam(learning_rate=0.0001), loss='sparse_categorical_crossentropy', metrics=['accuracy'])

        return eth_model


# Compile the model


# gender

# # Train the model
# gender_model.fit(train_images, train_gender, epochs=10)

# # Evaluate the model
# test_loss, test_acc = gender_model.evaluate(test_images, test_gender)
# print(f'Test Accuracy: {test_acc}')
def custom_mode(arr):
    result, _ = mode(arr)
    return result[0]

epoch = 5
class Bagging:
    def __init__(self, n_estimators):
        self.n_estimators = n_estimators
        self.estimators = []

    def fit(self, examples, targets, type):
        for _ in range(self.n_estimators):
            # TODO: Randomly select data points with replacement (bootstrapping)
            # TODO: Randomly sample a subset of attributes
            # TODO: Extract the sampled data
            # TODO: Create and train a decision tree on the sampled data with a call to IDTree
            # TODO: Append trained tree to tree_estimators
            indices = np.random.choice(len(examples), len(examples))
            X = examples[indices]
            y = targets[indices]

            # del_list = []
            # for i in range(len(attributes)):
            #     if i not in new_attributes:
            #         del_list.append(i)
            # X = np.delete(X, del_list, axis = 1)
            model = create_model(type)
            model.fit(X, y, epochs=epoch)
            self.estimators.append(model)

    def predict_gender(self, X, test_gender):
        # TODO: Make predictions using each tree in the ensemble
        # TODO: return majority vote as the final prediction
        result = [tree.predict(X) for tree in self.estimators]
        result = np.array(result)
        result[result >= 0.5] = 1
        result[result < 0.5] = 0
        result = np.sum(result,axis=0)
        result [2*result >= self.n_estimators]=1
        result[result!=1]=0
        ans = result
        test_gender = test_gender.reshape((-1,1))
        # print(test_gender.shape)
        s = np.sum(ans==test_gender)
        t = len(test_gender)
        # print("len",t)
        # print("sum",s)
        acc = s/t
        return acc
    
    def predict_age(self,X, test_age):
         # TODO: Make predictions using each tree in the ensemble
        # TODO: return majority vote as the final prediction
        result = [tree.predict(X) for tree in self.estimators]
        result = np.array(result)
        result = np.mean(result, axis=0)
        test_age = test_age.reshape((-1,1))
        acc = np.abs(result-test_age)
        acc = np.mean(acc)
        # result = np.array(result)
        # result[result >= 0.5] = 1
        # result[result < 0.5] = 0
        # result = np.sum(result,axis=0)
        # result [2*result >= self.n_estimators]=1
        # result[result!=1]=0
        # ans = result
        # test_gender = test_gender.reshape((-1,1))
        # # print(test_gender.shape)
        # s = np.sum(ans==test_gender)
        # t = len(test_gender)
        # # print("len",t)
        # # print("sum",s)
        # acc = s/t
        return acc
    
    def predict_eth(self,X, test_eth):
        result = [tree.predict(X) for tree in self.estimators]
        result = np.array(result)
        result  = np.argmax(result,axis=2)
        # value, count  = np.unique(result, return_counts = True)
        # count = 

        result = np.apply_along_axis(lambda x: np.argmax(np.bincount(x)), axis=0, arr=result)
        result = result.reshape((-1, 1))
        # print(test_eth_2.size)
        # test_eth_2 = np.argmax(test_eth,axis = 1)
        test_eth_2 = test_eth

        test_eth_2 = test_eth_2.reshape((-1,1))
        s = np.sum(result==test_eth_2)
        t = len(test_eth_2)
        # print("len",t)
        # print("sum",s)
        acc = s/t
        return acc






        # result[result >= 0.5] = 1
        # result[result < 0.5] = 0
        # result = np.sum(result,axis=0)
        # result [2*result >= self.n_estimators]=1
        # result[result!=1]=0
        # ans = result
        # test_gender = test_gender.reshape((-1,1))
        # # print(test_gender.shape)
        # s = np.sum(ans==test_gender)
        # t = len(test_gender)
        # # print("len",t)
        # # print("sum",s)
        # acc = s/t
        # return acc

    

n_estimators = 5

#============================================= Gender Prediction ==========================================================
'''
print("Gender Prediction")

bagging_gender = Bagging(n_estimators)
bagging_gender.fit(all_x, all_gender, 0)
# print(bagging.predict(all_x[0]))



acc = bagging_gender.predict_gender(test_images, test_gender)


# print(ans.shape)
# print(test_gender.shape)
# test_gender = test_gender.reshape((-1,1))
# # print(test_gender.shape)
# s = np.sum(ans==test_gender)
# t = len(test_gender)
# # print("len",t)
# # print("sum",s)
# acc = s/t

print("Accuracy of Gender Prediction is ", acc)
'''
#============================================= Age Prediction ==========================================================

print("Age Prediction")

bagging_age = Bagging(n_estimators)
bagging_age.fit(all_x, all_age, 1)
# print(bagging.predict(all_x[0]))


acc = bagging_age.predict_age(test_images, test_age)

# # print(ans.shape)
# # print(test_gender.shape)
# test_age = test_age.reshape((-1,1))
# # print(test_gender.shape)
# s = np.sum(ans==test_age)
# t = len(test_age)
# # print("len",t)
# # print("sum",s)
# acc = s/t

print("Accuracy of Age Prediction is ", acc)

#============================================= Ethinicity Prediction ==========================================================

print("Ethinicity Prediction")

bagging_ethinicity = Bagging(n_estimators)
bagging_ethinicity.fit(all_x, all_eth, 2)
# print(bagging.predict(all_x[0]))


acc = bagging_ethinicity.predict_eth(test_images, test_eth)

# print(ans.shape)
# print(test_gender.shape)
# test_eth = test_eth.reshape((-1,1))
# print(test_gender.shape)
# s = np.sum(ans==test_eth)
# t = len(test_eth)
# print("len",t)
# print("sum",s)
# acc = s/t

print("Accuracy of Ethinicity Prediction is ", acc)


'''
age_model = Sequential()
age_model.add(Conv2D(32, (7, 7), activation='relu', input_shape=(128, 128, 3)))
age_model.add(BatchNormalization())
age_model.add(MaxPooling2D((2, 2)))
age_model.add(Conv2D(64, (5, 5), activation='relu'))
age_model.add(BatchNormalization())
age_model.add(MaxPooling2D((2, 2)))
age_model.add(Conv2D(128, (5, 5), activation='relu'))
# age_model.add(Conv2D(128, (3, 3), activation='relu'))
# age_model.add(Conv2D(128, (3, 3), activation='relu'))
age_model.add(BatchNormalization())
age_model.add(MaxPooling2D((2, 2)))
age_model.add(Flatten())
# age_model.add(Dense(128, activation='relu'))
# age_model.add(Dropout(0.5))
# age_model.add(Dense(100, activation='sigmoid'))
age_model.add(Dense(128, activation='relu'))
age_model.add(Dropout(0.5))
age_model.add(Dense(1, activation='linear'))

# Compile the model
age_model.compile(optimizer=Adam(), loss='mae')
# age_model.compile(optimizer=Adam(learning_rate=0.001), loss='mae')

# Train the model
age_model.fit(train_images, train_age, epochs=15)

# Evaluate the model
test_Loss = age_model.evaluate(test_images, test_age)
print(f'Test Loss: {test_Loss}')

eth_model = Sequential()
eth_model.add(Conv2D(32, (7, 7), activation='relu', input_shape=(128, 128, 3)))
eth_model.add(BatchNormalization())
eth_model.add(MaxPooling2D((2, 2)))
eth_model.add(Conv2D(64, (5, 5), activation='relu'))
eth_model.add(BatchNormalization())
eth_model.add(MaxPooling2D((2, 2)))
eth_model.add(Conv2D(128, (5, 5), activation='relu'))
eth_model.add(Conv2D(128, (3, 3), activation='relu'))
eth_model.add(BatchNormalization())
eth_model.add(MaxPooling2D((2, 2)))
eth_model.add(Flatten())
eth_model.add(Dense(128, activation='relu'))
eth_model.add(Dropout(0.5))

eth_model.add(Dense(5, activation='softmax'))

# Compile the model
eth_model.compile(optimizer=Adam(learning_rate=0.0001), loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train the model
eth_model.fit(train_images, train_eth, epochs=10)

# Evaluate the model
test_Loss = eth_model.evaluate(test_images, test_eth)
print(f'Test Loss: {test_Loss}')

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Concatenate
from tensorflow.keras.models import Model

# Define input shapes for image and gender (assuming gender is a binary feature)
image_input_shape = (128, 128, 3)  # Example shape for an RGB image
gender_input_shape = (1,)        # Assuming gender is represented as 0 or 1

# Input layers for image and gender
image_input = Input(shape=image_input_shape, name='image_input')
gender_input = Input(shape=gender_input_shape, name='gender_input')



age_gender = Conv2D(32, (7, 7), activation='relu', input_shape=(128, 128, 3))(image_input)
age_gender = BatchNormalization()(age_gender)
age_gender = MaxPooling2D((2, 2))(age_gender)
age_gender = Conv2D(64, (5, 5), activation='relu')(age_gender)
age_gender = BatchNormalization()(age_gender)
age_gender = MaxPooling2D((2, 2))(age_gender)
age_gender = Conv2D(128, (5, 5), activation='relu')(age_gender)
age_gender = Conv2D(128, (3, 3), activation='relu')(age_gender)
age_gender = BatchNormalization()(age_gender)
age_gender = MaxPooling2D((2, 2))(age_gender)
flatten = Flatten()(age_gender)
concatenated = Concatenate()([flatten, gender_input])
dense1 = Dense(128, activation='relu')(concatenated)
output = Dense(1, activation='linear')(dense1)  # Output layer for age prediction


model_age_gen = Model(inputs=[image_input, gender_input], outputs=output)
model_age_gen.compile(optimizer='adam', loss='mean_squared_error', metrics=['mae'])
model_age_gen.fit([train_images, train_gender], train_age, epochs=10)
test_Loss = model_age_gen.evaluate([test_images, test_gender], test_age)
print(f'Test Loss: {test_Loss}')

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Concatenate
from tensorflow.keras.models import Model

# Define input shapes for image and gender (assuming gender is a binary feature)
image_input_shape = (128, 128, 3)  # Example shape for an RGB image
gender_input_shape = (1,)        # Assuming gender is represented as 0 or 1

# Input layers for image and gender
image_input = Input(shape=image_input_shape, name='image_input')
gender_input = Input(shape=gender_input_shape, name='gender_input')



eth_gender = Conv2D(32, (7, 7), activation='relu', input_shape=(128, 128, 3))(image_input)
eth_gender = BatchNormalization()(eth_gender)
eth_gender = MaxPooling2D((2, 2))(eth_gender)
eth_gender = Conv2D(64, (5, 5), activation='relu')(eth_gender)
eth_gender = BatchNormalization()(eth_gender)
eth_gender = MaxPooling2D((2, 2))(eth_gender)
eth_gender = Conv2D(128, (5, 5), activation='relu')(eth_gender)
eth_gender = Conv2D(128, (3, 3), activation='relu')(eth_gender)
eth_gender = BatchNormalization()(eth_gender)
eth_gender = MaxPooling2D((2, 2))(eth_gender)

flatten = Flatten()(eth_gender)
concatenated = Concatenate()([flatten, gender_input])
dense1 = Dense(128, activation='relu')(concatenated)
dense2 = Dropout(0.5)(dense1)
output = Dense(5, activation='softmax')(dense2)


model_eth_gen = Model(inputs=[image_input, gender_input], outputs=output)
model_eth_gen.compile(optimizer=Adam(learning_rate=0.0001), loss='sparse_categorical_crossentropy', metrics=['accuracy'])
model_eth_gen.fit([train_images, train_gender], train_eth, epochs=8)
test_Loss = model_eth_gen.evaluate([test_images, test_gender], test_eth)
print(f'Test Loss: {test_Loss}')

'''